Here in our application, let's start with the app.js file which is a class-based component and therefore here, we have access to lifecycle hooks. Now as I mentioned, the first thing that will execute is the constructor. The constructor receives some props and when you add a constructor as I mentioned, you have to call super props in here. This will basically execute the constructor of the component you're extending and that is important to make sure that everything gets initialized correctly and you can do things like access this set state. Now here, I simply want to log app.js constructor and I have that app.js identifier only there so that we can clearly see from which file this output stems. Now in the constructor, you could also initialize your state by the way. So we're doing it down there, you could do that whole state initialization also here instead of down there. This actually, this down here is just a more modern syntax which behind the scenes will basically add the constructor for you, call super props and set the state up in the constructor, that is what our old syntax, this one here actually does. If you don't want to use it or you're working in a project set up that doesn't support this more modern Javascript syntax, you can set state here in constructor and that will just work fine. Important just since you initialize the state, you should set the state like this and not with this set state because there will be no state to merge this state with. Now after the constructor, we learned that getDerivedStateFromProps runs. For that, I'll add getDerivedStateFromProps and this actually is a so-called static method, so you have to add the static keyword in front of it. This is just important for React so that React can execute this correctly. You will get your props and your state in here and you should return your updated state and here I'll just return the old state but of course I want to console log app.js getDerivedStateFromProps and I will also log my props here. Now after getDerivedStateFromProps, the render method executes, this one here, so let me console log app.js render and as I mentioned, then all the child components will be rendered. So all the person components will be rendered and if that were class-based components, we could add the lifecycle there too and see it run for all the persons, I'll not do it right now, though there is one thing I will do. In my persons component which is the component that is executed here, I will actually add a console log here, persons.js rendering because when the component gets rendered, even though it is a functional one, of course that code here gets executed, not here in the map though but actually outside of it. For that, let's wrap this with curly braces then add a return keyword here and then also add a closing curly brace after this so that we have a real function body here and now I just want to indicate that persons.js is rendering. Again, we can of course add this here because this function will be executed when this renders and therefore this console log will be printed too and in the person.js file so that we can see that too, here I'll also add a console log, person.js rendering. So now I change this, now back in app.js, render will execute, persons component will render, the individual person components in the persons component will then render and once all of that is done, componentDidMount will run, so here I'll add componentDidMount. componentDidMount would allow us to make an HTTP request for example and that is something we'll do later, for now I'll just output componentDidMount here. And now with all that setup work, let's see it in practice. So here if I open my console and I reload this page, we can clearly see the constructor, we see getDerivedStateFromProps and we see that props is an object with the app title, we see render and then we see componentDidMount. We don't see the outputs from the person components because these didn't render yet, right? If I toggle, then we see toggling actually also triggered getDerivedStateFromProps and then render for app.js ran, rendering for a persons.js ran and then three times rendering in person.js ran. So that is how the lifecycle hook works here, this is how we can go through the different lifecycle hooks when a component is created. It's also worth highlighting that historically, there were other hooks as well and these are still supported and I'll actually use one of them later in the course still. Now one of them was componentWillMount and I'm saying was even though it still exists because whilst you can use it, it's not insecure and nothing like that, these hooks were very rarely used and could be used incorrectly and therefore they will be removed in the future. Still as I mentioned, you can still use them, nothing wrong with that in general and so here I will execute componentWillMount. That was executed right before the componentWouldMount and indeed it would be hard to explain what kind of work you do in here, generally it would be something like preparing your state correctly and that is something you would now do in the getDerivedStateFromProps and both were actually relatively seldom to be used and therefore this will be removed and this one here is still there and will stay here but you'll actually not use that too often either. Now besides componentWillMount which still is there but it will be removed at some point in the future, we also got some other hooks which will only become important once we have a look at the updating lifecycle for components. Now accessing the render method by the way does not mean that the real DOM gets re-rendered, it simply means that React will now re-render its internal virtual DOM and then check if the real DOM needs to be changed and that is also something I'll dive into with you in this module where I dive a bit deeper into how React actually updates the DOM.