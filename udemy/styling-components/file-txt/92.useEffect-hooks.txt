Chúng ta hãy xem cockpit componen của chúng tôi, đây là một functional component và do đó ở đây, chúng ta có thể sử dụng React hooks nếu chúng ta sử dụng đúng phiên bản React thực sự hỗ trợ React hooks. Bây giờ ở đây, chúng ta không thể thêm componentDidMount hoặc bất cứ thứ gì tương tự nhưng tất nhiên chúng ta có thể quản lý state với useState, mặc dù điều đó không giúp chúng ta nhưng những gì chúng ta có thể sử dụng là một cái hook khác. Chúng ta phải nhập nó từ React và nó được gọi là useEffect. useEffect là hook React quan trọng thứ hai mà bạn có thể sử dụng bên cạnh useState vì useEffect và bây giờ nghe có vẻ lạ nhưng useEffect về cơ bản kết hợp chức năng hoặc các trường hợp sử dụng mà bạn có thể bao gồm tất cả các class-based lifecycle hook này trong một hook React ở đây và cả hai được gọi là hook, nó thực sự không liên quan. Đây không phải là lifecycle hook, đây là hook React nên về cơ bản là một chức năng bạn có thể thêm vào một trong các functional component của mình. Bây giờ nó hoạt động như thế nào? Bạn có thể thêm nó ở bất cứ đâu tại đây trong cơ thể functional component của bạn và useEffect làm mặc định có một chức năng sẽ chạy cho mỗi chu kỳ render. Vì vậy, ở đây tôi sẽ thêm console.log và đầu ra cockpit.js useEffect, như thế này. Nếu chúng ta lưu nó và tôi tải lại, chúng ta sẽ thấy cockpit.js useEffect đã sẵn sàng, vì vậy hàm này tôi đã chuyển sang useEffect và điều đó rất quan trọng, bạn chuyển vào một function ở đây không có bất kỳ đối số nào nhưng nó phải là một funtion, bạn truyền một function cho useEffect và điều này sẽ thực thi cho mọi chu kỳ render của cockpit. Nếu bây giờ tôi bấm vào đây, chúng tôi sẽ thấy nó một lần nữa bởi vì chúng tôi đã thay đổi một cái gì đó ở đây và nó được render lại cockpit đó. Nếu bây giờ tôi gõ một cái gì đó ở đây, chúng ta sẽ thấy useEffect một lần nữa. Tất nhiên không có gì thay đổi trong cockpit nếu tôi gõ ở đây nhưng vì chúng tôi chưa thêm bất kỳ tối ưu hóa hiệu suất nào cho đến nay, React về cơ bản sẽ render lại app.js khi chúng tôi nhập, vì trong app.js, chúng tôi quản lý state của Persons và state đó thay đổi khi chúng ta gõ và do đó nó gọi phương thức render của app.js và trong đó, tất nhiên chúng ta bao gồm cockpit của chúng ta và do đó cockpit cũng được render lại. Như mọi khi tôi nói được render lại, tôi không có nghĩa là trong DOM thực như bạn sẽ học nhưng trong DOM ảo đó, React sẽ kiểm tra xem nó có cần chạm vào DOM thật hay không. Chúng tôi có thể ngăn chặn điều này và chúng tôi sẽ làm như vậy sau nhưng bây giờ, nó là như vậy. Vì vậy, useEffect chạy ở đây, nó chạy cho mọi bản cập nhật và điều này có nghĩa là chúng ta đã có thể sử dụng nó cho tất cả những điều chúng ta sẽ làm trong componentDidUupdate và thực sự điều đó là ổn. Nếu bạn cần gửi một HTTP request hoặc bất cứ điều gì tương tự ở đây, bạn có thể làm điều đó. Nó rõ ràng cũng chạy khi component được tạo, bởi vì nếu tôi nhanh chóng lưu nó và tôi tải lại ứng dụng của mình và do đó cockpit được tạo ra, nó ở đây, nó thực thi vì nó thực thi cho mọi chu kỳ render và bao gồm cả chu kỳ render đầu tiên. Vì vậy, nó là componentDidMount và componentDidUpdate kết hợp trong một effect. Bây giờ một số hook như getDerivingStateFromProps không được bao gồm ở đây nhưng bạn cũng không thực sự cần nó bởi vì nếu bạn có props ở đây và bạn muốn dựa vào state của mình, thì bạn có thể useState và chuyển một số dữ liệu từ props của mình làm ban đầu state vào đây, phải không? Vì vậy, bạn có điều đó được xây dựng trong này bởi vì nó là một functional component theo định nghĩa. useEffect dành cho các hook vòng đời khác quan trọng hơn và hữu ích hơn mà tôi muốn nói.