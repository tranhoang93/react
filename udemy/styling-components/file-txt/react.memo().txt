Before we have a look at the internal re-rendering process, let's have a look at how we can optimize performance with functional components though because shouldComponentUpdate is a great tool but it's only available in class-based components. Now what about functional components, what can we do there, what about the cockpit component? Because with the paint flashing, we see that and I will disable this now, we see that of course the cockpit is never touched when I type here but still we can tell that it executed its code. So how can we prevent this if nothing about the cockpit changed? And for that, we first of all have to look at the cockpit and we see that the only thing that the cockpit uses internally and that therefore should trigger a re-rendering of that cockpit are the persons length here and then also this title. The names of the persons and so on are totally irrelevant. So what can you do now to prevent this unnecessary re-rendering? React also has a tool for functional components. You can wrap your export, so your entire component here in the cockpit.js file with React memo. This basically uses memoization which is a technique where React will memoize, so basically store a snapshot of this component and only if its input changes, it will re-render it and otherwise if its inputs do not change and some parent component wants to update this cockpit component, React will give back that stored component. So therefore now initially this of course runs because there is no stored data and here it actually runs again, now why is that? Because in the cockpit component, it only re-renders when its props change but of course one of the props we depend on is the persons. We only use the length but that is not something React picks up here. To fix that, we can optimize the way we pass data into our cockpit though. Here on cockpit instead of passing in the persons, we can pass in the persons length let's say which is this state persons length. So instead of determining the length inside of the cockpit, we do it outside of the cockpit now and we only pass in persons length. This of course will now only change if the persons length here changes. So now back in the cockpit.js file where I used props persons.length, I use props persons length but this is now a separate property, there is no dot in between, I'm not accessing a length property here, this is a new prop I get. Now with that, we made that calculation or we outsourced that calculation that used the complete persons array which of course changes with every keystroke, we outsourced this into app.js and now we only get data that does not change with every keystroke and therefore now if I clear this, if I type here, we see nothing about cockpit.js being executed here. This will only happen once we do something that does affect the cockpit, so then you see that run but you don't see any cockpit output for changes that do not relate to it. So React memo is a great way of also getting optimization for your functional components and therefore it is a good idea to wrap functional components that might not need to update with every change in the parent component with it.
==========VN=========
Trước khi chúng ta xem xét quá trình kết xuất lại nội bộ, hãy xem cách chúng ta có thể tối ưu hóa hiệu suất với các thành phần chức năng mặc dù vì ShouldComponentUpdate là một công cụ tuyệt vời nhưng nó chỉ khả dụng trong các thành phần dựa trên lớp. Bây giờ những gì về các thành phần chức năng, chúng ta có thể làm gì ở đó, Còn thành phần buồng lái thì sao? Bởi vì với màu sơn nhấp nháy, chúng tôi thấy điều đó và tôi sẽ vô hiệu hóa điều này ngay bây giờ, chúng tôi thấy rằng tất nhiên là buồng lái không bao giờ chạm vào khi tôi gõ ở đây nhưng chúng ta vẫn có thể nói rằng nó đã thực thi mã của nó. Vậy làm thế nào chúng ta có thể ngăn chặn điều này nếu không có gì về buồng lái thay đổi? Và vì điều đó, trước hết chúng ta phải nhìn vào buồng lái và chúng ta thấy rằng điều duy nhất mà buồng lái sử dụng nội bộ và do đó sẽ kích hoạt kết xuất lại buồng lái đó là chiều dài người ở đây và sau đó là danh hiệu này. Tên của những người và như vậy là hoàn toàn không liên quan. Vì vậy, những gì bạn có thể làm bây giờ để ngăn chặn tái hiện không cần thiết này? Phản ứng cũng có một công cụ cho các thành phần chức năng. Bạn có thể bọc xuất khẩu của mình, vì vậy toàn bộ thành phần của bạn ở đây trong tệp cockpit.js với bản ghi nhớ React. Điều này về cơ bản sử dụng ghi nhớ là một kỹ thuật trong đó React sẽ ghi nhớ, vì vậy về cơ bản lưu trữ một ảnh chụp nhanh của thành phần này và chỉ khi đầu vào của nó thay đổi, nó sẽ kết xuất lại nó và nếu không, đầu vào của nó không thay đổi và một số thành phần cha mẹ muốn cập nhật thành phần buồng lái này, React sẽ trả lại thành phần được lưu trữ đó. Vì vậy, bây giờ ban đầu điều này tất nhiên chạy vì có không có dữ liệu được lưu trữ và ở đây nó thực sự chạy lại, bây giờ tại sao vậy? Bởi vì trong thành phần buồng lái, nó chỉ tái hiện khi đạo cụ của nó thay đổi nhưng tất nhiên một trong những đạo cụ mà chúng ta phụ thuộc là người. Chúng tôi chỉ sử dụng độ dài nhưng đó không phải là thứ React chọn ở đây. Để khắc phục điều đó, chúng ta có thể tối ưu hóa cách chúng tôi truyền dữ liệu vào buồng lái của chúng tôi mặc dù. Ở đây trên buồng lái thay vì đi qua người, chúng ta có thể vượt qua trong chiều dài người hãy nói đó là chiều dài của người này. Vì vậy, thay vì xác định chiều dài bên trong buồng lái, chúng tôi thực hiện bên ngoài buồng lái Bây giờ và chúng tôi chỉ vượt qua chiều dài người. Điều này tất nhiên sẽ chỉ thay đổi nếu chiều dài người ở đây thay đổi. Vì vậy, bây giờ trở lại trong tệp cockpit.js nơi tôi đã sử dụng đạo cụ Person.length, Tôi sử dụng đạo cụ chiều dài người nhưng đây là một tài sản riêng, không có dấu chấm ở giữa, tôi không truy cập vào một thuộc tính độ dài ở đây, Đây là một chỗ dựa mới tôi nhận được. Bây giờ với điều đó, chúng tôi đã thực hiện phép tính đó hoặc chúng tôi đã thuê ngoài phép tính đó đã sử dụng mảng người hoàn chỉnh, tất nhiên thay đổi với mỗi lần nhấn phím, chúng tôi đã gia công phần này vào app.js và bây giờ chúng tôi chỉ nhận được dữ liệu không thay đổi với mỗi lần nhấn phím và do đó bây giờ nếu tôi xóa điều này, nếu tôi gõ vào đây, chúng ta sẽ không thấy gì về cockpit.js được thực thi ở đây. Điều này sẽ chỉ xảy ra khi chúng ta làm gì đó có ảnh hưởng đến buồng lái, Vì vậy, sau đó bạn thấy chạy nhưng bạn không thấy bất kỳ đầu ra buồng lái nào cho những thay đổi không liên quan đến nó. Vì thế React memo là một cách tuyệt vời để nhận được tối ưu hóa cho các thành phần chức năng của bạn và do đó đó là một ý tưởng tốt để bọc các thành phần chức năng có thể không cần cập nhật với mỗi thay đổi trong thành phần cha mẹ với nó.