Let's have a look at our cockpit component, this is a functional component still and therefore in here, we can use React hooks if we're using the right React version that actually supports React hooks of course. Now in here, we can't add componentDidMount or anything like that but we can of course manage state with useState, though that doesn't help us but what we can use is another hook. We have to import it from React and it's called useEffect. useEffect is the second most important React hook you can use next to useState because useEffect and now that sounds strange but useEffect basically combines the functionality or the use cases you can cover of all these class-based lifecycle hooks in one React hook here and both is called hook, it's actually not related. This is not a lifecycle hook, this is a React hook so basically a function you can add into one of your functional components. Now how does it work? You can add it anywhere here in your functional component body and useEffect as a default takes a function that will run for every render cycle. So here I will add console log and output cockpit.js useEffect, like this. If we save that and I reload, we see cockpit.js useEffect already, so this function I passed to useEffect and that's important, you pass in a function here which doesn't take any arguments but it has to be a function, you pass a function to useEffect and this will execute for every render cycle of the cockpit. If I now click here, we see it again because we changed something here and that re-rendered that cockpit. If I now type something here, we see useEffect again. Of course nothing changed in the cockpit if I type here but because we haven't added any performance optimizations thus far, React will basically re-render app.js when we type because in app.js, we manage the state of the persons and that state changes when we type and therefore it calls the render method of app.js and in there, we of course include our cockpit and so the cockpit gets re-rendered too. As always when I say re-rendered, I don't mean in the real DOM as you will learn but in that virtual DOM, React will check if it needs to touch the real DOM. We can prevent this and we'll do so later but for now, it is what it is. So useEffect runs here, it runs for every update and this means we can already use it for all the things we would have done in componentDidUupdate and indeed that is OK. If you need to send an HTTP request or anything like that in here, you can do that. It also obviously runs when the component is created, right because if I quickly save this and I reload my app and therefore the cockpit is created, it is up here, it executed because it executes for every render cycle and that includes the first one. So it is componentDidMount and componentDidUpdate combined in one effect. Now some hooks like getDerivedStateFromProps is not included in here but you also don't really need it because if you have props here and you want to base your state on that, well then you can useState and pass some data from your props as an initial state into this, right? So you have that built into this because it is a functional component per definition. useEffect is for the other, more important and useful lifecycle hooks I'd say.