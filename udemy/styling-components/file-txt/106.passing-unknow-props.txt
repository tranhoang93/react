tiếng anh
So now with the higher order component created, let's maybe also use it in the person.js file for a single person where I also want to have a class around it, right? I use my aux component here because I want to demonstrate the aux component but we actually have some CSS class code set up that we could use here. Now we can of course simply import withClass here from the higher order component folder and then the withClass file and then we can use this higher order component on the person component as well. It's not limited to being used in one component only, you can bring it into any component that needs the functionality this higher order component adds and the functionality this higher order component adds is that it adds a wrapping div with some CSS code. So therefore, let's now use it here, withClass and let's pass the person component as the first argument and the class I want to add is classes.person, using the CSS modules and this person class here. Now with that, with everything set up, that should bring back our styles for the persons. So if we toggle them, yes the styling is back but the data is missing and do you know what's wrong here? The data is missing because what we're doing is we're taking our person component and right before we export it, we pass it into the withClass function. Now what does the withClass function do? The withClass function takes the component and outputs it not before wrapping it into an extra div that adds the CSS class. The div doesn't really matter but what is missing on the wrapped component which in the case of the person component being passed is just our person component. Well it's missing all its props, I'm outputting wrapped components like this and I haven't set any props here. Of course we could set name as a prop here but for one, this is now hardcoded and second, now every component using that higher order component would receive Maximilian as we can see here and that is certainly not what we want, even though it's a great name of course. Well, we can pass props dynamically and that is a pretty powerful feature of Javascript and React. We actually do accept our props here and this will be the props of our wrapped component because we return this functional component in our higher order component, so ultimately, this withClass finger returns the functional component that wraps our person component. So we export whatever withClass returns, so we export this functional component returned by withClass and therefore anyone importing from person component and using the export here as person, as we do it here in the persons file, this here refers just to the result of the withClass call. So it refers to this functional component and therefore any props we pass to person here in the persons component will end up in our withClass component here. So props will actually be the right props and now we can use a JSX syntax that allows us to forward props to the wrapped component. Now what doesn't work is that we set props equal to props because React automatically takes all the attributes you add to your JSX code and combines them in a props object. So now props would not replace that props object but be added as a single property in the props passed to the wrapped component. But instead, you can use another syntax where you use curly braces and then a feature called the spread operator where you spread the props you're getting. The props you're getting here is a Javascript object and the spread operator pulls out all the properties that are inside of this props object and distributes them as new key-value pairs on this wrapped component. So if props here is a Javascript object with a name of Maximilian and an age of 28, then this syntax here will effectively set name equal to Maximilian and age equal to 28, like this. This is in the end what will happen here automatically behind the scenes for you. And therefore now with this setup here, if we save that, on the reloaded page, you'll see our data is back and it works just as it did before, thanks to props being used and props being passed to the wrapped component here.
TIẾNG VIỆT===========================================================================================================
Vì vậy, bây giờ với thành phần bậc cao hơn được tạo, chúng ta cũng có thể sử dụng nó trong tệp person.js cho một người mà tôi cũng muốn có một lớp xung quanh nó, phải không? Tôi sử dụng thành phần phụ trợ của mình ở đây vì tôi muốn chứng minh thành phần phụ trợ nhưng chúng tôi thực sự có một số mã lớp CSS được thiết lập mà chúng ta có thể sử dụng ở đây. Bây giờ tất nhiên chúng ta có thể chỉ cần nhập withClass ở đây từ thư mục thành phần bậc cao hơn và sau đó là tệp withClass và sau đó chúng ta có thể sử dụng thành phần bậc cao này trên thành phần người. Không giới hạn chỉ được sử dụng trong một thành phần, bạn có thể đưa nó vào bất kỳ thành phần nào cần chức năng mà thành phần bậc cao này thêm vào và chức năng mà thành phần bậc cao này thêm vào là nó thêm div gói với một số mã CSS. Vì vậy, bây giờ chúng ta hãy sử dụng nó ở đây, withClass và hãy chuyển thành phần person làm đối số đầu tiên và lớp tôi muốn thêm là class.person, sử dụng các mô-đun CSS và lớp người này ở đây. Bây giờ với điều đó, với tất cả mọi thứ được thiết lập, điều đó sẽ mang lại phong cách của chúng tôi cho mọi người. Vì vậy, nếu chúng ta chuyển đổi chúng, vâng, kiểu dáng đã trở lại nhưng dữ liệu bị thiếu và bạn có biết điều gì sai ở đây không? Dữ liệu bị thiếu vì những gì chúng tôi đang làm là chúng tôi lấy thành phần cá nhân của mình và ngay trước khi chúng tôi xuất dữ liệu, chúng tôi chuyển nó vào hàm withClass. Bây giờ hàm withClass làm gì? Hàm withClass lấy thành phần và xuất ra nó trước khi gói nó vào một div bổ sung có thêm lớp CSS. Div không thực sự quan trọng nhưng những gì còn thiếu trên thành phần được bọc trong trường hợp thành phần người được thông qua chỉ là thành phần người của chúng ta. Chà, nó thiếu tất cả các đạo cụ của nó, tôi xuất ra các bộ phận được bọc như thế này và tôi chưa đặt bất kỳ đạo cụ nào ở đây. Tất nhiên chúng ta có thể đặt tên là một chỗ dựa ở đây nhưng đối với một, đây là mã hóa cứng và thứ hai, bây giờ mọi thành phần sử dụng thành phần bậc cao hơn đó sẽ nhận được Maximilian như chúng ta có thể thấy ở đây và đó chắc chắn không phải là điều chúng ta muốn, mặc dù đó là tên tuyệt vời của khóa học Chà, chúng ta có thể chuyển các đạo cụ một cách linh hoạt và đó là một tính năng khá mạnh mẽ của Javascript và React. Chúng tôi thực sự chấp nhận đạo cụ của chúng tôi ở đây và đây sẽ là đạo cụ của thành phần được bọc bởi vì chúng tôi trả lại thành phần chức năng này trong thành phần bậc cao hơn của chúng tôi, vì vậy, cuối cùng, ngón tay withClass này trả về thành phần chức năng bao bọc thành phần người của chúng tôi. Vì vậy, chúng tôi xuất bất cứ thứ gì mà trả về với Class, vì vậy chúng tôi xuất thành phần chức năng này được withClass trả về và do đó, bất kỳ ai nhập từ thành phần người và sử dụng xuất ở đây với tư cách cá nhân, như chúng tôi thực hiện ở đây trong tệp cá nhân, ở đây chỉ đề cập đến kết quả của với cuộc gọi bằng kính. Vì vậy, nó đề cập đến thành phần chức năng này và do đó, bất kỳ đạo cụ nào chúng ta chuyển cho người ở đây trong thành phần người sẽ kết thúc trong thành phần withClass của chúng ta ở đây. Vì vậy, đạo cụ thực sự sẽ là đạo cụ phù hợp và bây giờ chúng ta có thể sử dụng cú pháp JSX cho phép chúng ta chuyển tiếp đạo cụ đến thành phần được bọc. Bây giờ, điều không hiệu quả là chúng tôi đặt các đạo cụ bằng với các đạo cụ vì React tự động lấy tất cả các thuộc tính bạn thêm vào mã JSX của bạn và kết hợp chúng trong một đối tượng đạo cụ. Vì vậy, bây giờ đạo cụ sẽ không thay thế đối tượng đạo cụ đó mà được thêm vào dưới dạng một thuộc tính duy nhất trong các đạo cụ được truyền cho thành phần được bọc. Nhưng thay vào đó, bạn có thể sử dụng một cú pháp khác trong đó bạn sử dụng dấu ngoặc nhọn và sau đó là một tính năng được gọi là toán tử trải rộng nơi bạn truyền bá đạo cụ bạn nhận được. Các đạo cụ bạn nhận được ở đây là một đối tượng Javascript và toán tử trải rộng lấy ra tất cả các thuộc tính bên trong đối tượng đạo cụ này và phân phối chúng dưới dạng các cặp giá trị khóa mới trên thành phần được bao bọc này. Vì vậy, nếu đạo cụ ở đây là một đối tượng Javascript có tên Maximilian và tuổi 28, thì cú pháp ở đây sẽ đặt tên hiệu quả bằng Maximilian và tuổi bằng 28, như thế này. Đây là cuối cùng những gì sẽ xảy ra ở đây tự động đằng sau hậu trường cho bạn. Và do đó, với thiết lập này ở đây, nếu chúng ta lưu nó, trên trang được tải lại, bạn sẽ thấy dữ liệu của chúng tôi đã hoạt động trở lại và nó hoạt động như trước đây, nhờ các đạo cụ được sử dụng và các đạo cụ được chuyển đến thành phần được bọc ở đây.